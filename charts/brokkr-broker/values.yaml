---
# Broker container image configuration
image:
  # Container registry and repository for the broker image
  repository: ghcr.io/colliery-io/brokkr-broker
  # Image tag to deploy (use 'latest' for development, specific versions for production)
  tag: latest
  # Image pull policy (IfNotPresent, Always, Never)
  pullPolicy: IfNotPresent
  # Image pull secrets for private registries
  # pullSecrets:
  #   - name: ghcr-secret

# Number of broker replicas to run
# Note: Multiple replicas require session affinity or external session storage
replicaCount: 1

# Kubernetes Service configuration
service:
  # Service type: ClusterIP (internal), LoadBalancer (external), NodePort
  type: ClusterIP
  # Service port for broker HTTP API
  port: 3000
  # Additional service annotations (useful for LoadBalancer configuration)
  # annotations:
  #   service.beta.kubernetes.io/aws-load-balancer-type: "nlb"

# PostgreSQL database configuration
postgresql:
  # enabled: true deploys a bundled PostgreSQL instance (development/testing)
  # enabled: false uses an external PostgreSQL instance (production)
  enabled: true

  # External database configuration (used when enabled=false)
  external:
    # External database host (required when postgresql.enabled=false)
    host: ''
    # Database port
    port: 5432
    # Database name
    database: brokkr
    # Database username (not used when existingSecret is set)
    username: brokkr
    # Database password (not used when existingSecret is set)
    # WARNING: Do not commit production passwords to values files
    password: brokkr

  # Use an existing Kubernetes secret for database credentials
  # The secret should contain a key with the full database connection URL
  # Applies to both bundled and external PostgreSQL
  # existingSecret: my-database-secret
  existingSecret: ''
  # Key name in existingSecret that contains the database URL
  # Default: database-url
  existingSecretKey: database-url

  # Bitnami PostgreSQL subchart configuration (used when enabled=true)
  # See https://github.com/bitnami/charts/tree/main/bitnami/postgresql for all options

  auth:
    # PostgreSQL username for broker application
    username: brokkr
    # PostgreSQL password for broker application
    # WARNING: Override this in production with a secure value or use existingSecret
    password: brokkr
    # PostgreSQL database name
    database: brokkr

  # Primary PostgreSQL instance configuration
  primary:
    # Persistence configuration for PostgreSQL data
    persistence:
      # Enable persistent storage (recommended for production)
      # Set to false for ephemeral storage (testing only - data lost on pod restart)
      enabled: true
      # Storage class to use for PVC
      # Empty string uses cluster default storage class
      storageClass: ""
      # Size of persistent volume
      size: 8Gi

    # Resource requests and limits for PostgreSQL
    resources:
      requests:
        memory: "256Mi"
        cpu: "250m"
      limits:
        memory: "512Mi"
        cpu: "500m"

# Additional environment variables to inject into broker pods
# Useful for configuration not covered by standard values
# extraEnv:
#   - name: RUST_LOG
#     value: "debug"
#   - name: CUSTOM_CONFIG
#     valueFrom:
#       configMapKeyRef:
#         name: my-config
#         key: custom-value
extraEnv: []

# Resource requests and limits for broker pods
# Requests: minimum guaranteed resources
# Limits: maximum resources before throttling/eviction
resources:
  requests:
    memory: 256Mi
    cpu: 100m
  limits:
    memory: 512Mi
    cpu: 500m

# Security context for broker pods
# Run as non-root user for enhanced security
securityContext:
  runAsNonRoot: true
  runAsUser: 10001
  fsGroup: 10001

# TLS/SSL configuration for secure communications
tls:
  # Enable TLS for the broker (requires certificates)
  enabled: false

  # Use an existing Kubernetes TLS secret
  # The secret should be of type kubernetes.io/tls with tls.crt and tls.key
  existingSecret: ''

  # Provide certificates inline (base64 encoded)
  # WARNING: Only use for testing. Production should use existingSecret or cert-manager
  # To generate self-signed cert: openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
  #   -keyout tls.key -out tls.crt -subj "/CN=brokkr.example.com"
  cert: ''
  key: ''

  # Cert-manager integration for automatic certificate management
  certManager:
    # Enable cert-manager certificate generation
    enabled: false
    # Name of the cert-manager issuer to use
    issuer: 'letsencrypt-prod'
    # Issuer kind: Issuer or ClusterIssuer
    issuerKind: 'ClusterIssuer'

# Ingress configuration for external access
ingress:
  # Enable ingress resource creation
  enabled: false

  # Ingress class name (nginx, traefik, etc.)
  # Required for Kubernetes 1.18+
  className: 'nginx'

  # Ingress annotations for additional configuration
  # Common annotations:
  #   cert-manager.io/cluster-issuer: "letsencrypt-prod"
  #   nginx.ingress.kubernetes.io/ssl-redirect: "true"
  #   nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
  annotations: {}

  # Ingress host configuration
  hosts:
    - host: brokkr.example.com
      paths:
        - path: /
          pathType: Prefix

  # TLS configuration for ingress
  # If cert-manager is enabled, certificates will be automatically generated
  # Otherwise, the secretName should reference an existing TLS secret
  tls:
    - secretName: brokkr-tls
      hosts:
        - brokkr.example.com
