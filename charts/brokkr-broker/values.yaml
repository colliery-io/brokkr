---
# =============================================================================
# CONFIGURATION HOT-RELOAD SUPPORT
# =============================================================================
# Some settings can be changed without restarting the broker pod. These are
# marked with "@hot-reload: true" comments throughout this file.
#
# Hot-reloadable settings:
#   - log.level
#   - broker.diagnosticCleanupIntervalSeconds
#   - broker.diagnosticMaxAgeHours
#   - broker.webhookDeliveryIntervalSeconds
#   - broker.webhookDeliveryBatchSize
#   - broker.webhookCleanupRetentionDays
#   - cors.allowedOrigins
#   - cors.maxAgeSeconds
#
# Static settings (require pod restart):
#   - database.url, database.schema
#   - broker.webhookEncryptionKey
#   - telemetry.* (all telemetry settings)
#   - tls.* (all TLS settings)
#
# To trigger a manual reload, call: POST /api/v1/admin/config/reload
# In Kubernetes, the broker automatically watches its ConfigMap for changes.
# =============================================================================

# Configuration hot-reload settings
configReload:
  # Enable automatic ConfigMap watching in Kubernetes
  # When enabled, the broker watches for ConfigMap changes and reloads
  # hot-reloadable settings automatically (with 5-second debounce)
  enabled: true

  # Debounce duration in seconds to prevent rapid successive reloads
  debounceSeconds: 5

# Broker container image configuration
image:
  # Container registry and repository for the broker image
  repository: ghcr.io/colliery-io/brokkr-broker
  # Image tag to deploy (use 'latest' for development, specific versions for production)
  tag: latest
  # Image pull policy (IfNotPresent, Always, Never)
  pullPolicy: IfNotPresent
  # Image pull secrets for private registries
  # pullSecrets:
  #   - name: ghcr-secret

# Number of broker replicas to run
# Note: Multiple replicas require session affinity or external session storage
replicaCount: 1

# HorizontalPodAutoscaler configuration for automatic scaling
# When enabled, overrides replicaCount with dynamic scaling
autoscaling:
  # Enable horizontal pod autoscaling
  enabled: false

  # Minimum number of replicas
  minReplicas: 1

  # Maximum number of replicas
  maxReplicas: 5

  # Target CPU utilization percentage for scaling
  # When average CPU exceeds this, HPA scales up
  targetCPUUtilizationPercentage: 70

  # Target memory utilization percentage for scaling (optional)
  # Uncomment to also scale on memory
  # targetMemoryUtilizationPercentage: 80

  # Scaling behavior configuration (optional)
  # Controls how fast HPA scales up/down
  # behavior:
  #   scaleDown:
  #     stabilizationWindowSeconds: 300
  #     policies:
  #       - type: Percent
  #         value: 50
  #         periodSeconds: 60
  #   scaleUp:
  #     stabilizationWindowSeconds: 0
  #     policies:
  #       - type: Percent
  #         value: 100
  #         periodSeconds: 15
  #       - type: Pods
  #         value: 4
  #         periodSeconds: 15
  #     selectPolicy: Max

# Kubernetes Service configuration
service:
  # Service type: ClusterIP (internal), LoadBalancer (external), NodePort
  type: ClusterIP
  # Service port for broker HTTP API
  port: 3000
  # Additional service annotations (useful for LoadBalancer configuration)
  # annotations:
  #   service.beta.kubernetes.io/aws-load-balancer-type: "nlb"

# PostgreSQL database configuration
postgresql:
  # enabled: true deploys a bundled PostgreSQL instance (development/testing)
  # enabled: false uses an external PostgreSQL instance (production)
  enabled: true

  # External database configuration (used when enabled=false)
  external:
    # External database host (required when postgresql.enabled=false)
    host: ''
    # Database port
    port: 5432
    # Database name
    database: brokkr
    # Database username (not used when existingSecret is set)
    username: brokkr
    # Database password (not used when existingSecret is set)
    # WARNING: Do not commit production passwords to values files
    password: brokkr
    # PostgreSQL schema for multi-tenant deployments (optional)
    # When set, the broker will use this schema for data isolation
    # Leave empty for default (public) schema
    # Example: 'tenant_a', 'customer_1', 'dev', 'staging', 'prod'
    schema: ''

  # Use an existing Kubernetes secret for database credentials
  # The secret should contain a key with the full database connection URL
  # Applies to both bundled and external PostgreSQL
  # existingSecret: my-database-secret
  existingSecret: ''
  # Key name in existingSecret that contains the database URL
  # Default: database-url
  existingSecretKey: database-url

  # Bitnami PostgreSQL subchart configuration (used when enabled=true)
  # See https://github.com/bitnami/charts/tree/main/bitnami/postgresql for all options

  auth:
    # PostgreSQL username for broker application
    username: brokkr
    # PostgreSQL password for broker application
    # WARNING: Override this in production with a secure value or use existingSecret
    password: brokkr
    # PostgreSQL database name
    database: brokkr

  # Primary PostgreSQL instance configuration
  primary:
    # Persistence configuration for PostgreSQL data
    persistence:
      # Enable persistent storage (recommended for production)
      # Set to false for ephemeral storage (testing only - data lost on pod restart)
      enabled: true
      # Storage class to use for PVC
      # Empty string uses cluster default storage class
      storageClass: ""
      # Size of persistent volume
      size: 8Gi

    # Resource requests and limits for PostgreSQL
    resources:
      requests:
        memory: "256Mi"
        cpu: "250m"
      limits:
        memory: "512Mi"
        cpu: "500m"

# Additional environment variables to inject into broker pods
# Useful for configuration not covered by standard values
# extraEnv:
#   - name: RUST_LOG
#     value: "debug"
#   - name: CUSTOM_CONFIG
#     valueFrom:
#       configMapKeyRef:
#         name: my-config
#         key: custom-value
extraEnv: []

# Broker application settings
# These control runtime behavior of the broker
broker:
  # Log level for the broker application
  # @hot-reload: true - changes apply without restart
  # Valid values: trace, debug, info, warn, error
  logLevel: info

  # Diagnostic cleanup settings
  # @hot-reload: true - changes apply without restart
  diagnosticCleanupIntervalSeconds: 900  # 15 minutes
  diagnosticMaxAgeHours: 1

  # Webhook delivery settings
  # @hot-reload: true - changes apply without restart
  webhookDeliveryIntervalSeconds: 5
  webhookDeliveryBatchSize: 50
  webhookCleanupRetentionDays: 7

  # Webhook encryption key (hex-encoded 32-byte key)
  # @hot-reload: false - requires restart
  # If not set, a random key is generated on startup
  # WARNING: Changing this will make existing encrypted webhook data unreadable
  # webhookEncryptionKey: ""

# CORS configuration for API access
# @hot-reload: true - changes apply without restart (except allowCredentials)
cors:
  # Allowed origins for CORS requests
  # Use "*" to allow all origins (not recommended for production)
  allowedOrigins:
    - "*"

  # Allowed HTTP methods
  allowedMethods:
    - GET
    - POST
    - PUT
    - PATCH
    - DELETE
    - OPTIONS

  # Allowed request headers
  allowedHeaders:
    - Authorization
    - Content-Type
    - Accept

  # Max age for CORS preflight cache (seconds)
  # @hot-reload: true
  maxAgeSeconds: 3600

# Resource requests and limits for broker pods
# Requests: minimum guaranteed resources
# Limits: maximum resources before throttling/eviction
resources:
  requests:
    memory: 256Mi
    cpu: 100m
  limits:
    memory: 512Mi
    cpu: 500m

# AppArmor configuration
# AppArmor provides additional security but requires AppArmor-enabled host
apparmor:
  # Enable AppArmor annotations (requires AppArmor support on cluster nodes)
  enabled: false
  # AppArmor profile to use (runtime/default is most common)
  profile: runtime/default

# Pod-level security context for broker
# Controls security settings that apply to all containers in the pod
podSecurityContext:
  runAsNonRoot: true
  runAsUser: 10001
  runAsGroup: 10001
  fsGroup: 10001
  # Seccomp profile for syscall filtering (Kubernetes 1.19+)
  # Uncomment for production security hardening
  # seccompProfile:
  #   type: RuntimeDefault

# Container-level security context for broker
# Controls security settings specific to the broker container
containerSecurityContext:
  # Prevent privilege escalation
  allowPrivilegeEscalation: false
  # Enable read-only root filesystem for maximum security
  # Note: Requires emptyDir volumes for /tmp and other writable paths
  readOnlyRootFilesystem: false
  runAsNonRoot: true
  runAsUser: 10001
  # Drop all Linux capabilities and add back only required ones
  capabilities:
    drop:
      - ALL
    # Uncomment if specific capabilities are needed
    # add:
    #   - NET_BIND_SERVICE

# TLS/SSL configuration for secure communications
tls:
  # Enable TLS for the broker (requires certificates)
  enabled: false

  # Use an existing Kubernetes TLS secret
  # The secret should be of type kubernetes.io/tls with tls.crt and tls.key
  existingSecret: ''

  # Provide certificates inline (base64 encoded)
  # WARNING: Only use for testing. Production should use existingSecret or cert-manager
  # To generate self-signed cert: openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
  #   -keyout tls.key -out tls.crt -subj "/CN=brokkr.example.com"
  cert: ''
  key: ''

  # Cert-manager integration for automatic certificate management
  certManager:
    # Enable cert-manager certificate generation
    enabled: false
    # Name of the cert-manager issuer to use
    issuer: 'letsencrypt-prod'
    # Issuer kind: Issuer or ClusterIssuer
    issuerKind: 'ClusterIssuer'

# Ingress configuration for external access
ingress:
  # Enable ingress resource creation
  enabled: false

  # Ingress class name (nginx, traefik, etc.)
  # Required for Kubernetes 1.18+
  className: 'nginx'

  # Ingress annotations for additional configuration
  # Common annotations:
  #   cert-manager.io/cluster-issuer: "letsencrypt-prod"
  #   nginx.ingress.kubernetes.io/ssl-redirect: "true"
  #   nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
  annotations: {}

  # Ingress host configuration
  hosts:
    - host: brokkr.example.com
      paths:
        - path: /
          pathType: Prefix

  # TLS configuration for ingress
  # If cert-manager is enabled, certificates will be automatically generated
  # Otherwise, the secretName should reference an existing TLS secret
  tls:
    - secretName: brokkr-tls
      hosts:
        - brokkr.example.com

# Metrics and monitoring configuration
metrics:
  # Enable Prometheus metrics endpoint at /metrics
  enabled: true

  # ServiceMonitor configuration for Prometheus Operator
  serviceMonitor:
    # Enable ServiceMonitor CRD creation
    # Requires Prometheus Operator to be installed in the cluster
    enabled: false

    # Scrape interval for Prometheus
    interval: 30s

    # Scrape timeout (must be shorter than interval)
    # scrapeTimeout: 10s

    # Additional labels for ServiceMonitor (for Prometheus selector matching)
    # additionalLabels:
    #   prometheus: kube-prometheus

# NetworkPolicy configuration for restricting pod network access
networkPolicy:
  # Enable NetworkPolicy creation
  enabled: false

  # Allow ingress from specific sources (list of podSelector/namespaceSelector)
  # If empty, allows from any pod in the same namespace
  # Example:
  #   allowIngressFrom:
  #     - namespaceSelector:
  #         matchLabels:
  #           kubernetes.io/metadata.name: ingress-nginx
  #       podSelector:
  #         matchLabels:
  #           app.kubernetes.io/name: ingress-nginx
  allowIngressFrom: []

  # Allow metrics scraping from Prometheus namespace
  # Example:
  #   allowMetricsFrom:
  #     - namespaceSelector:
  #         matchLabels:
  #           kubernetes.io/metadata.name: monitoring
  allowMetricsFrom: []

  # Allow egress for webhook deliveries to external HTTPS endpoints
  allowWebhookEgress: true

  # Additional custom egress rules
  # additionalEgressRules:
  #   - to:
  #       - ipBlock:
  #           cidr: 10.0.0.0/8
  #     ports:
  #       - protocol: TCP
  #         port: 443
  additionalEgressRules: []

# PodDisruptionBudget configuration for high availability during updates
podDisruptionBudget:
  # Enable PodDisruptionBudget creation
  enabled: false

  # Minimum number of pods that must be available during voluntary disruptions
  # Can be an integer or a percentage (e.g., "50%")
  minAvailable: 1

  # Maximum number of pods that can be unavailable during voluntary disruptions
  # Alternative to minAvailable - only set one
  # maxUnavailable: 1

# OpenTelemetry telemetry configuration for distributed tracing
telemetry:
  # Enable OpenTelemetry tracing
  enabled: false

  # OTLP endpoint for trace export (gRPC)
  # Examples:
  #   - Local collector: http://otel-collector:4317
  #   - Jaeger OTLP: http://jaeger-collector:4317
  #   - Tempo: http://tempo:4317
  otlpEndpoint: "http://otel-collector:4317"

  # Sampling rate (0.0 to 1.0)
  # 0.1 = 10% of traces sampled (recommended for production)
  # 1.0 = 100% of traces sampled (development/debugging)
  samplingRate: 0.1

  # Optional: Deploy OpenTelemetry Collector as a sidecar
  # This is useful when the main collector is not accessible from the broker
  collector:
    # Enable OTel collector sidecar
    enabled: false

    # Collector image
    image:
      repository: otel/opentelemetry-collector-contrib
      tag: "0.96.0"
      pullPolicy: IfNotPresent

    # Resource limits for collector sidecar
    resources:
      requests:
        memory: 64Mi
        cpu: 50m
      limits:
        memory: 128Mi
        cpu: 100m

    # OTLP exporters configuration
    # Where the sidecar collector sends traces
    exporters:
      # OTLP exporter endpoint (e.g., central collector, Jaeger, Tempo)
      otlpEndpoint: ""
      # Enable debug exporter (logs traces to stdout)
      debug: false
